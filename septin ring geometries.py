import numpy as np
from PIL import Image, ImageDraw
import random
import os
import math

#this script generates .rgn geometry files to be imported into Fluosim
#generated geometries are non-overlapping circles (200 points around center point) with a pre-defined radius and thickness

#specify were geometry files should be written to
path = r'C:\Users\Jakob\box.fu\Collaborations\Machine Learning\360 nm new\new BG and new rings'

canvas = 100                                #pixel, size of the canvas

peaktopeak=360                              #define diameter of rings (peak to peak)
ring_thickness = 150                        #define thickness of rings

size = peaktopeak + ring_thickness/2        #nm, diameter of  outer ring
size_inner = peaktopeak - ring_thickness/2  #nm, diameter of inner ring
number = 100                                #total number of rings
pixelsize = 100                             #nm
random_ring =0                              #nm, adds 'error' to each point in circle so that they become less perfect
random_thickness= 0                         #nm, adds 'error' to thickness of each ring so that they become less uniform
distance = 0                                #nm, minimal distance of rings, alwas non overlapping

#changes where script draws circles so that they are not at the very edges of the canvas
absolut_x_offset= 1000
absolut_y_offset= 1000

#define the outer borders of the geometries, this is important for Fluosim as it will act as contour region (Region 0)
outline = [absolut_x_offset-random_ring, absolut_y_offset-random_ring, absolut_x_offset+canvas*100-2000 +random_ring, absolut_y_offset-random_ring, absolut_x_offset+canvas*100-2000+random_ring, absolut_y_offset +canvas*100-2000+random_ring, absolut_x_offset-random_ring, absolut_y_offset +canvas*100-2000+random_ring]

#generate black image with outline to later visualize which points are generated by script
im = Image.new('RGB', (canvas*100, canvas*100))
draw = ImageDraw.Draw(im)
draw.polygon(outline)

r = size/2
r_inner = size_inner/2

r_ceil = np.ceil(r)
r_inner_ceil = np.ceil(r_inner)

counter_ring = 0 #counts up each time ring is added to final array
counter_point = 0 #counts up each time point of ring is added to final array

temp = 400

final_array = np.zeros(((number*11), temp))

j= 0

random_array = np.zeros((number, 2))

i=0


#generate array of random numbers, which will be used as the center of the circles
#written in a way so that the circles never overlap

while i < number:
    offy = random.randint(absolut_y_offset + r_ceil, absolut_y_offset + canvas*pixelsize-2000 - r_ceil)
    offx = random.randint(absolut_x_offset + r_ceil, absolut_x_offset + canvas*pixelsize-2000 - r_ceil)

    n = i

    while n > 0:
        if abs(offy - random_array[i-n,1]) > (size + distance) or abs(offx - random_array[i-n, 0]) > (size + distance):
                n -= 1
    #print(i, n, random_array[i-n,1], offy, bool (abs(offy - random_array[i-n,1]) > 20) )

        else:
            offy = random.randint(absolut_y_offset + r_ceil, absolut_y_offset + canvas* pixelsize-2000 - r_ceil)
            offx = random.randint(absolut_x_offset + r_ceil, absolut_x_offset + canvas* pixelsize-2000 - r_ceil)
            n = i

    random_array[i, 1] = offy
    random_array[i, 0] = offx
    i += 1

    #print(random_array)


for n in range (0,number):
    offx = random_array[n, 0]
    offy = random_array[n, 1]

    thickness_error = random.randint(-random_thickness, random_thickness) #make error in thickness for each ring

    for p in np.arange(math.pi / 100, 2*math.pi, 2 * math.pi / 100):

        #generate 200 point of center point for outer circle
        #also adds random integer to points to make circles less perfect
        Px = offx + r * math.cos(p) + random.randint(0, random_ring)
        Py = offy + r * math.sin(p) + random.randint(0, random_ring)

        #generate 200 point of center point for inner circle
        #also adds random integer to points to make circles less perfect
        Px_inner = offx + (r_inner+ thickness_error) * math.cos(p) + random.randint(0, random_ring)
        Py_inner = offy + (r_inner+ thickness_error) * math.sin(p) + random.randint(0, random_ring)

        #add coordinates for outer circle to final array
        final_array[counter_ring, 2*counter_point-1] = Py/pixelsize
        final_array[counter_ring, 2*counter_point] = Px/pixelsize

        #add coordinates for inner circle to final array
        final_array[counter_ring, 200 + 2 * counter_point] = Px_inner / pixelsize
        final_array[counter_ring, 200 + (2 * counter_point-1)] = Py_inner / pixelsize

        #draw point to visualize geometry that was generated, this has no effect on the data that is written to .rgn file
        draw.point((Px, Py))
        draw.point((Px_inner, Py_inner))
        counter_point += 1

    counter_point = 0
    counter_ring += 1


#im.show(im)

output_name = "channel-model_size-of-channel=" + str(size) + "_number-of-channels=" + str(number)

outline = np.array(outline)/100

if os.path.isfile(path + '/' + output_name + '.rgn'):
    os.remove(path + '/' + output_name + '.rgn')

outline_row = "0 3, 1 16711680, 2 0 0, 3 0 0, 4 0, 5 1, 6 4 "
for i in range(0, 8):
    outline_row = outline_row + str(outline[i]) + " "

outline_row = outline_row + ",7 1"

with open(path + '/' + output_name + '.rgn', 'a') as the_file:
    the_file.write(outline_row + '\n')

#write generated points of circles to file
#new line = .... defines the geometry of the shape, last number is important as it defines the total number of point in the polygon
for j in range(0, number):
    new_row = "0 3, 1 16711680, 2 0 0, 3 0 0, 4 0, 5 1, 6 200 "

    for i in range(0, temp):
        new_row = new_row + str(final_array[j, i]) + " "
    new_row = new_row + ",7 1"

    with open(path + '/' + output_name + '.rgn', 'a') as the_file:
        the_file.write(new_row + '\n')

#export visualization of generated points
#im.save(path + '/' + output_name + ".png")

#export background image to import into Fluosim
background = Image.new('RGB', (canvas, canvas))
background.save(path + '/' + output_name + '_background' + ".png")

