import numpy as np
from PIL import Image, ImageDraw
import random
import os
import math

#this script generates .rgn geometry files to be imported into Fluosim
#generated geometries are overlapping polygons that mimic immunofluorescence background

path = r'C:\Users\Jakob\box.fu\Collaborations\Machine Learning\360 nm new\new BG and new rings'
canvas = 100        #pixel, size of the canvas
size = 50           #nm, distance of edge from center point
number = 100        #total number of polygons
pixelsize = 100     #nm
random_ring =500    #nm, adds 'error' to each point in polygon so that they become less perfect
distance = 0        #nm, minimal distance of center of polygons
num_edges = 20      #number of edges of polygons

#changes where script draws polygon so that its not add the verry edges of image
absolut_x_offset = 1000
absolut_y_offset = 1000

#define the outer borders of the geometries, this is important for Fluosim as it will act as contour region (Region 0)
outline = [absolut_x_offset-random_ring, absolut_y_offset-random_ring,
           absolut_x_offset+canvas * pixelsize - 2000 +random_ring, absolut_y_offset-random_ring,
           absolut_x_offset+canvas * pixelsize - 2000 + random_ring,
           absolut_y_offset +canvas * pixelsize - 2000+random_ring, absolut_x_offset-random_ring,
           absolut_y_offset +canvas * pixelsize -2000+random_ring]

#generate black image with outline to later visualize which points are generated by script
im = Image.new('RGB', (canvas * pixelsize, canvas * pixelsize))
draw = ImageDraw.Draw(im)
draw.polygon(outline)

r = size

counter_ring = 0 #counts up each time ring is added to final array
counter_point = 0 #counts up each time point of ring is added to final array

final_array = np.zeros(((number), 2*num_edges))
random_array = np.zeros((number, 2))
array_edges = np.zeros((number, 1))

i=0

#generate array of random numbers, which will be used as the center of the polygon
#written in a way so that the polygons never overlap
while i < number:

    offy = random.randint(absolut_y_offset + r, absolut_y_offset + canvas * pixelsize - 2000 - r)
    offx = random.randint(absolut_x_offset + r, absolut_x_offset + canvas * pixelsize - 2000 - r)

    n = i

    loop_counter = 0 #counts up each time polygons would overlap

    while n > 0:


        if abs(offy - random_array[i-n,1]) > (size + distance) or abs(offx - random_array[i-n, 0]) > (size + distance):

                n -= 1

        else:
            offy = random.randint(absolut_y_offset + r, absolut_y_offset + canvas * pixelsize - 2000 - r)
            offx = random.randint(absolut_x_offset + r, absolut_x_offset + canvas * pixelsize - 2000 - r)

            n = i
            loop_counter += 1

            if loop_counter > 100: #if script can't fit polygon non-overlapping into canvas after 100 tries leave loop

                break

    if loop_counter > 100:

        print('Could only fit', i, 'objects. Decrease size or distance of objects or increase canvas size')

        break

    random_array[i, 1] = offy
    random_array[i, 0] = offx
    i += 1

    #print(random_array)


for n in range (0,number):
    offx = random_array[n, 0]
    offy = random_array[n, 1]

    num_edges_loop = random.randint(2, num_edges)
    array_edges[n] = num_edges_loop

    for p in np.arange(0, 2*math.pi, 2 * math.pi / num_edges_loop):

        #generate points around center point for polygon
        #also adds random integer to points to make polygon less perfect
        Px = offx + r * math.cos(p) + random.randint(-random_ring, random_ring)
        Py = offy + r * math.sin(p) + random.randint(-random_ring, random_ring)


        #add coordinates for polygon to final array
        final_array[counter_ring, 2*counter_point + 1] = Py/pixelsize
        final_array[counter_ring, 2*counter_point] = Px/pixelsize

        #draw point to visualize geometry that was generated, this has no effect on the data that is written to .rgn file
        draw.point((Px, Py))

        counter_point += 1

    counter_point = 0
    counter_ring += 1

#print(final_array)
#im.show(im)

output_name = "background"

outline = np.array(outline) / pixelsize

if os.path.isfile(path + '/' + output_name + '.rgn'):
    os.remove(path + '/' + output_name + '.rgn')

outline_row = "0 3, 1 16711680, 2 0 0, 3 0 0, 4 0, 5 1, 6 4 "
for i in range(0, 8):
    outline_row = outline_row + str(outline[i]) + " "

outline_row = outline_row + ",7 1"

with open(path + '/' + output_name + '.rgn', 'a') as the_file:
    the_file.write(outline_row + '\n')

#write generated point of polygon to .rgn file
#new line = .... defines the geometry of the shape
#last number is importat as it defines the total number of point in the polygon
for j in range(0, number):
    new_row = "0 3, 1 16711680, 2 0 0, 3 0 0, 4 0, 5 1, 6 " + str(int(array_edges[j])) + " "


    for i in range(0, 2*int(array_edges[j])):
        new_row = new_row + str(final_array[j, i]) + " "
        #print(final_array[j, i])

    new_row = new_row + ",7 1"

    with open(path + '/' + output_name + '.rgn', 'a') as the_file:
        the_file.write(new_row + '\n')

#export visualization of generated points
#im.save(path + '/' + output_name + ".png")

#export back background image to import into Fluosim
background = Image.new('RGB', (canvas, canvas))
background.save(path + '/' + output_name + '_background' + ".png")